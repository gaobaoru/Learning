学习总结：
（1）	构造函数尽量用initialization List；
（2）	书写函数时，确定函数是否需要加const；
（3）	参数传递尽量使用引用，能否用const要视情况而定；
（4）	返回参数尽量用引用，若是函数内新建的局部变量必定不能用引用；
（5）	Class declaration 中数据尽量放在private，函数大部分放在public中。可以使用友元函数，可以直接获取私有成员。
交流群经典语录：
1、	最好的动态内存管理原则是 谁new 谁负责delete。而且尽量在一个函数内做。
2、	在成熟的类库中，一个函数返回 一些new的动态内存，然后让caller去负责delete，也是很常见的。(虽然原则还是尽量避免)
3、	另外一种做法是在 函数调用之前 就把 动态内存 创建好。 p=new... ; func(p);  delete p;
4、	在实际应用中，不建议容器做返回类型，用输出参数形式比较好，比如：std::vector<T>& output，建议尽量用stl而不是原生数组，即函数运用输入输出参数，双向操作。
5、	编程最大的艺术就是 反复，反复，再反复。
6、	这要取决于：基础，学习的投入，职业目标。如果是定位BAT或者硅谷高端一些的岗位，还需要高级班的学习。如果是中档岗位，这个班级的课程，大家只要保证学习质量，技术方面基本都没问题（希望高级班能够优惠）。
7、	任何类型都可以做返回值。
8、	但如果是size很大的容器对象，返回时做拷贝构造的成本可能会很高，可以采用右值引用，可以减少额外的拷贝构造函数和析构函数的开销。并且在函数里的局部变量可以通过右值引用的方式返回。
9、	 inline的需求主要是看代码量是否足够小，从而免除函数调用的plumbing成本。 与运算符，还是什么无直接关系。只不过很多运算符 的函数体都很小，所以将它们inline很常见。不过 提示一下inline只是 programmer 对compiler的建议，而采纳不采纳compiler会有自己的决定。
10、	一定要在思考下去写代码，不仅know how, 也要know why，是培养良好技术思维的前提。
补充杂谈：
本周涉及到的一些补充杂谈，个人能力有限，可能有不足之处，共同学习，有心者可继续补充，总结如下：
1、C/C++中随机数生成：
因为rand（）函数是按指定的顺序来产生整数，因此每次执行上面的语句都打印相同的两个值，所以说C语言的随机并不是真正意义上的随机。
为了程序在每次执行时都能生成一个新序列的随机值，我们通常通过为随机数生成器提供一粒新的随机种子。函数srand()(来自stdlib.h)可以为随机数生成器播散种子。只要种子不同rand()函数就会产生不同的随机数序列。srand()称为随机数生成器的初始化器。
调用方法是srand((unsigned)time(NULL));但是又不能在每次调用rand()的时候都用srand((unsigned)time(NULL));来初始化，因为现在计算机运行时间比较快，当连续调用rand()时，系统的时间还没有更新，所以得到的随机种子在一段时间内是完全相同的，因此一般只在进行一次大批随机数产生之前进行一次随机种子的初始化。 srand()函数定义 ： void srand (unsigned int seed);  通常可以利用geypid()或time(0)的返回值来当做seed 如果你用time(0)的话，要加入头文件#include<time.h>。
2、C++右值引用：
理解右值引用是学习“移动语义”的基础，必须先区分左值和右值。对于左值和右值的定义，大家都有一个常见的误解是：等号左边的就是左值，等号右边的就是右值。左值和右值都是针对表达式而言的，左值是指表达式结束后依然存在的持久对象，右值是指表达式结束后不再存在的临时对象。区分左值和右值的一个快捷方法是：看能不能对表达式取地址，如果能，则为左值；如果不能，则为右值。
详细介绍：右值引用可以减少额外的拷贝构造函数和析构函数的开销。
http://www.cnblogs.com/hujian/archive/2012/02/13/2348621.html
3、智能指针：
智能指针(smart pointer)是存储指向动态分配（堆）对象指针的类，用于生存期控制，能够确保自动正确的销毁动态分配的对象，防止内存泄露。它的一种通用实现技术是使用引用计数(reference count)。智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。
智能指针就是模拟指针动作的类。所有的智能指针都会重载 -> 和 * 操作符。智能指针还有许多其他功能，比较有用的是自动销毁。这主要是利用栈对象的有限作用域以及临时对象（有限作用域实现）析构函数释放内存。当然，智能指针还不止这些，还包括复制时可以修改源对象等。智能指针根据需求不同，设计也不同（写时复制，赋值即释放对象拥有权限、引用计数等，控制权转移等）。
http://blog.csdn.net/hackbuteer1/article/details/7561235
